Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software : engineering after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, mmimaintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t prograng. We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

1. Com base nos parágrafos em questão, a Engenharia de Software pode ser definida como o ramo que lida com a criação, desenvolvimento e manutenção dos sistemas de softwares de maneira metódica e eficaz. Há uma diferença entre programação e engenharia de software, como relata o texto. A programação é uma das partes que compõe a engenharia de software, que por sua vez se mostra em um campo muito mais amplo do que a mesma.



2. Alguns exemplos de trade-offs:

           1 - Desempenho x Consumo de dados: otimizar algoritmos para melhorar o desempenho pode resultar em maior consumo de recursos computacionais;
           2 - Segurança x Usabilidade: exigir senhas mais complexas/autenticação de dois fatores aumenta o percentual de segurança de um software, porém também pode tornar o processo de login menos conveniente para o usuário;
           3 - Manutenção x Desempenho: adicionar uma camada de abstração para facilitar futuras mudanças e permitir configurações flexíveis pode tornar o código mais modular e fácil de manter, mas também pode resultar em um sistema mais complexo e exigir uma revisão intensa para implementar mudanças significativas.
